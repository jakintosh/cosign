package service_test

import (
	"cosign/internal/service"
	"errors"
	"strings"
	"testing"
)

// mockKeyStore is a test implementation of KeyStore
type mockKeyStore struct {
	keys map[string]*service.APIKey
	err  error
}

func newMockKeyStore() *mockKeyStore {
	return &mockKeyStore{
		keys: make(map[string]*service.APIKey),
	}
}

func (m *mockKeyStore) Insert(id string, hash, salt []byte, createdAt int64) error {
	if m.err != nil {
		return m.err
	}
	m.keys[id] = &service.APIKey{
		ID:        id,
		Hash:      hash,
		Salt:      salt,
		CreatedAt: createdAt,
	}
	return nil
}

func (m *mockKeyStore) GetByID(id string) (*service.APIKey, error) {
	if m.err != nil {
		return nil, m.err
	}
	key, exists := m.keys[id]
	if !exists {
		return nil, service.ErrAPIKeyNotFound
	}
	return key, nil
}

func (m *mockKeyStore) List() ([]*service.APIKey, error) {
	if m.err != nil {
		return nil, m.err
	}
	var keys []*service.APIKey
	for _, key := range m.keys {
		keys = append(keys, key)
	}
	return keys, nil
}

func (m *mockKeyStore) Delete(id string) error {
	if m.err != nil {
		return m.err
	}
	if _, exists := m.keys[id]; !exists {
		return service.ErrAPIKeyNotFound
	}
	delete(m.keys, id)
	return nil
}

// Test CreateAPIKey - happy path with custom ID
func TestCreateAPIKeyHappyPath(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	key, err := service.CreateAPIKey("test-key")

	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if key == "" {
		t.Fatal("Expected API key string, got empty")
	}

	// Check format: {id}.{secret}
	parts := strings.SplitN(key, ".", 2)
	if len(parts) != 2 {
		t.Errorf("Expected key format 'id.secret', got %q", key)
	}
	if parts[0] != "test-key" {
		t.Errorf("Expected ID 'test-key', got %q", parts[0])
	}
	if parts[1] == "" {
		t.Fatal("Expected non-empty secret")
	}

	// Verify key was stored
	storedKey, _ := store.GetByID("test-key")
	if storedKey == nil {
		t.Fatal("Expected key to be stored in database")
	}
}

// Test CreateAPIKey - auto-generated ID
func TestCreateAPIKeyAutoGeneratedID(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	key, err := service.CreateAPIKey("")

	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if key == "" {
		t.Fatal("Expected API key string, got empty")
	}

	// Check format and that ID starts with "key-"
	parts := strings.SplitN(key, ".", 2)
	if len(parts) != 2 {
		t.Errorf("Expected key format 'id.secret', got %q", key)
	}
	if !strings.HasPrefix(parts[0], "key-") {
		t.Errorf("Expected auto-generated ID to start with 'key-', got %q", parts[0])
	}
}

// Test CreateAPIKey - no store
func TestCreateAPIKeyNoStore(t *testing.T) {
	service.SetKeyStore(nil)

	_, err := service.CreateAPIKey("test-key")

	if err != service.ErrNoKeyStore {
		t.Errorf("Expected ErrNoKeyStore, got %v", err)
	}
}

// Test CreateAPIKey - multiple keys
func TestCreateAPIKeyMultiple(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	key1, _ := service.CreateAPIKey("key-1")
	key2, _ := service.CreateAPIKey("key-2")

	if key1 == key2 {
		t.Error("Expected different keys, but got identical values")
	}

	// Verify both are stored
	_, err1 := store.GetByID("key-1")
	_, err2 := store.GetByID("key-2")
	if err1 != nil || err2 != nil {
		t.Error("Expected both keys to be stored")
	}
}

// Test VerifyAPIKey - valid key
func TestVerifyAPIKeyValid(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	// Create a key
	fullKey, err := service.CreateAPIKey("test-key")
	if err != nil {
		t.Fatalf("Failed to create API key: %v", err)
	}

	// Verify it
	valid, err := service.VerifyAPIKey(fullKey)

	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if !valid {
		t.Error("Expected valid key to verify as true")
	}
}

// Test VerifyAPIKey - invalid format (no dot)
func TestVerifyAPIKeyInvalidFormatNoDot(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	_, err := service.VerifyAPIKey("nodot")

	if err != service.ErrInvalidAPIKeyFormat {
		t.Errorf("Expected ErrInvalidAPIKeyFormat, got %v", err)
	}
}

// Test VerifyAPIKey - invalid format (multiple dots)
func TestVerifyAPIKeyInvalidFormatMultipleDots(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	// Should use only the first dot as separator
	_, err := service.VerifyAPIKey("id.secret.extra")

	if err != nil {
		// This is actually valid format (splits on first dot only)
		t.Logf("Key with multiple dots parsed as id='id', secret='secret.extra'")
	}
}

// Test VerifyAPIKey - nonexistent key ID
func TestVerifyAPIKeyNonexistentID(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	valid, err := service.VerifyAPIKey("nonexistent.somesecret")

	if err != nil {
		t.Errorf("Expected no error (just false), got %v", err)
	}
	if valid {
		t.Error("Expected nonexistent key to verify as false")
	}
}

// Test VerifyAPIKey - wrong secret
func TestVerifyAPIKeyWrongSecret(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	// Create a key
	fullKey, _ := service.CreateAPIKey("test-key")

	// Try to verify with wrong secret
	parts := strings.SplitN(fullKey, ".", 2)
	wrongKey := parts[0] + ".wrongsecret"

	valid, err := service.VerifyAPIKey(wrongKey)

	if err != nil {
		t.Errorf("Expected no error (just false), got %v", err)
	}
	if valid {
		t.Error("Expected wrong secret to verify as false")
	}
}

// Test VerifyAPIKey - empty secret
func TestVerifyAPIKeyEmptySecret(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	// Create a key
	fullKey, _ := service.CreateAPIKey("test-key")
	parts := strings.SplitN(fullKey, ".", 2)

	// Try with empty secret
	valid, err := service.VerifyAPIKey(parts[0] + ".")

	if err != nil {
		t.Errorf("Expected no error (just false), got %v", err)
	}
	if valid {
		t.Error("Expected empty secret to verify as false")
	}
}

// Test VerifyAPIKey - no store
func TestVerifyAPIKeyNoStore(t *testing.T) {
	service.SetKeyStore(nil)

	_, err := service.VerifyAPIKey("test-key.secret")

	if err != service.ErrNoKeyStore {
		t.Errorf("Expected ErrNoKeyStore, got %v", err)
	}
}

// Test ListAPIKeys - happy path
func TestListAPIKeysHappyPath(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	service.CreateAPIKey("key-1")
	service.CreateAPIKey("key-2")
	service.CreateAPIKey("key-3")

	keys, err := service.ListAPIKeys()

	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if len(keys) != 3 {
		t.Errorf("Expected 3 keys, got %d", len(keys))
	}

	// Verify secrets are not included
	for _, key := range keys {
		if len(key.Hash) == 0 {
			t.Error("Expected hash to be stored (internal use only)")
		}
	}
}

// Test ListAPIKeys - empty list
func TestListAPIKeysEmpty(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	keys, err := service.ListAPIKeys()

	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if len(keys) != 0 {
		t.Errorf("Expected 0 keys, got %d", len(keys))
	}
}

// Test ListAPIKeys - no store
func TestListAPIKeysNoStore(t *testing.T) {
	service.SetKeyStore(nil)

	_, err := service.ListAPIKeys()

	if err != service.ErrNoKeyStore {
		t.Errorf("Expected ErrNoKeyStore, got %v", err)
	}
}

// Test DeleteAPIKey - happy path
func TestDeleteAPIKeyHappyPath(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	key, _ := service.CreateAPIKey("test-key")
	parts := strings.SplitN(key, ".", 2)
	id := parts[0]

	err := service.DeleteAPIKey(id)

	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}

	// Verify it's deleted
	_, verifyErr := service.VerifyAPIKey(key)
	if verifyErr != nil {
		t.Errorf("Expected no error on verify (key just won't match), got %v", verifyErr)
	}
}

// Test DeleteAPIKey - nonexistent key
func TestDeleteAPIKeyNonexistent(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	err := service.DeleteAPIKey("nonexistent")

	if err != service.ErrAPIKeyNotFound {
		t.Errorf("Expected ErrAPIKeyNotFound, got %v", err)
	}
}

// Test DeleteAPIKey - no store
func TestDeleteAPIKeyNoStore(t *testing.T) {
	service.SetKeyStore(nil)

	err := service.DeleteAPIKey("test-key")

	if err != service.ErrNoKeyStore {
		t.Errorf("Expected ErrNoKeyStore, got %v", err)
	}
}

// Test CreateAPIKey consistency
func TestCreateAPIKeyConsistency(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	// Create same ID twice and verify the secret is different
	key1, _ := service.CreateAPIKey("consistent-id")
	parts1 := strings.SplitN(key1, ".", 2)

	// Reset store to force it to accept the same ID
	store2 := newMockKeyStore()
	service.SetKeyStore(store2)

	key2, _ := service.CreateAPIKey("consistent-id")
	parts2 := strings.SplitN(key2, ".", 2)

	// IDs should be same, but secrets should be different (random)
	if parts1[0] != parts2[0] {
		t.Error("Expected same ID")
	}
	if parts1[1] == parts2[1] {
		t.Error("Expected different random secrets")
	}
}

// Test VerifyAPIKey - hash correctness
func TestVerifyAPIKeyHashCorrectness(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	// Create a key
	fullKey, _ := service.CreateAPIKey("test-key")

	// Verify multiple times - should be consistent
	for i := range 5 {
		valid, err := service.VerifyAPIKey(fullKey)
		if err != nil {
			t.Errorf("Iteration %d: expected no error, got %v", i, err)
		}
		if !valid {
			t.Errorf("Iteration %d: expected key to remain valid", i)
		}
	}
}

// Test store error propagation
func TestCreateAPIKeyStoreError(t *testing.T) {
	store := newMockKeyStore()
	store.err = errors.New("database error")
	service.SetKeyStore(store)

	_, err := service.CreateAPIKey("test-key")

	if !errors.Is(err, store.err) {
		t.Errorf("Expected database error, got %v", err)
	}
}

// Test VerifyAPIKey - case sensitivity
func TestVerifyAPIKeyCaseSensitivity(t *testing.T) {
	store := newMockKeyStore()
	service.SetKeyStore(store)

	fullKey, _ := service.CreateAPIKey("test-key")

	// Secrets should be case-sensitive
	parts := strings.SplitN(fullKey, ".", 2)
	wrongCase := parts[0] + "." + strings.ToUpper(parts[1])

	valid, err := service.VerifyAPIKey(wrongCase)

	if err != nil {
		t.Errorf("Expected no error (just false), got %v", err)
	}
	if valid {
		t.Error("Expected case-sensitive secret verification")
	}
}
